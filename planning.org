

* Things to work on next
** Extract out gdrive stuff
  * Code will be cleaner if this has its own file
  * If I do it right, it should be easier to test the other code took

functionality I need
  * Init
  * get (changes) start page token
  * get a batch of changes to process
    For this, we might use closures:
    http://stackoverflow.com/questions/14000534/what-is-most-idiomatic-way-to-create-an-iterator-in-go
    Or we might expect the caller to pass in a func that gets caller
    per change.
  * fetch gnode by id
  * fetch gnode children
  * download gnode content to a temp file

** I'm locking upward on writes and basically not locking properly when going downward on dump.  fix that.
* Things to work on at some point
** Investigate inotify support
See https://github.com/camlistore/camlistore/issues/244
See https://github.com/bazil/fuse/issues/34
See https://github.com/rvoicilas/inotify-tools/wiki
** Bug: in gdrive if I create a test folder with containing to children with the same name, and then ls it, I see both but they appear to have the same inode number.  I see that .dump conains reasonable stuff.  I think this is happening:

   . I return 2 correct direntry elements
   . Lookup gets called twice, based on name only
   . Each time I just grab the first entry and return that as a result of the Lookup call, so it ends up with the same Inode
   . I wonder what happens if I just don't implement Lookup.  It doesn't make sense if a directory can contain two files with the same name

   So this does appear to be the problem, and if I don't implement
   Lookup, then things won't work.

   I'm now thinking about forcing the files to have unique names
   within a directory.  Sticking .<idx> or .<creationdate> at the end
   would be one way to handle it.  Note that this could result in a
   new name collision which I would then have to handle, as unlikely
   as that is.

   I would need to make sure I don't end up writing this fake name
   back to gdrive by accident.

   Also, when new files appear, they can cause collisions.  In that
   case can I reliably apply the new suffix to just the new children?
   It will be confusing if an existing file is now renamed for no
   reason.

   I could add a data structure to each directory to track nodes per
   name to aid in this.

   We need to deal with these display names both when they come into
   use (e.g. Lookup) and we we return things (e.g. ReadDirAll, Attr).

   It seems like it would we want the parent to notice every time a
   new duplicate appears (or an old one goes away)?  When a new one
   appears, we would walk the duplicate children, and tell each of
   them they have a new unique display name they will use from then
   on.
** consider tracking last-viewed time as attr atime
** Umm, write mode
** Can we reduce change notification spam by filtering out fields we don't care about?
** Allow live configuration via writing to a magic file?  Could turn on and off logging etc.
** Do something useful with file modes
** Have some kind of /recent directory with symlinks to the actual nodes
** Track last-read-time of nodes, evict old ones to save memory
