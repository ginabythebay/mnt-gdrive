* Things to work on next
** gscan2pdf
  While I can use gscan2pdf to save to a pdf and then use cp to copy
  that pdf to my drive, I can't save directly into drive (if I do
  that, it seems to work, but creates a corrupt file that google drive
  does not recognize as being a pdf at all)

  Note that I see it calling getattr after write calls and I keep
  returning a 0 for the size.  That might be the issue.
** coherency
  Currently if an app opens a file twice, I treat them as completely
  separate entities.  As a matter of fact, changes to a file (e.g. the
  size and the mod time) never make it back into the meta data except
  as polled changes that are implied after I write things back to
  gdrive.

  Related, doing `echo "foo" > bob.txt` results in:
    open bob.txt
    setattr to truncate bob.txt
    flush open file handle
    write to open file handle
    flush open file handle
    release open file handle

  I need to make sure the truncation gets applied to the open file.  I
  should also make sure that the attribute changes (e.g. size,
  modtime) get reflected in my metadata.

  So, I think I need to ensure that there is at most one tmp file per
  node, no matter how many open calls are outstanding.  When SetAttr
  is called with a size, forward that to the tmpfile, if the file is
  open.

  If the file was not open when setattr is called with the size, then
   open it, apply setattr and flush/close it.

  per-handle fields
    accessMode
    fetchMode?

  per openFile fields
    fetch state
    tmpFile
    dirty

  need to add openFile.flush() which uploads and then marks things no longer dirty

  add openfile.truncate() which can change the length of the file.  Also node.Attr needs to be aware of the current length (even before flushing)

  for node, we will add

  openMu
  openCount (usually 0)
  *openFile (usuall nil)

* Things to work on at some point
** Investigate inotify support
See https://github.com/camlistore/camlistore/issues/244
See https://github.com/bazil/fuse/issues/34
See https://github.com/rvoicilas/inotify-tools/wiki
** Bug when 2 files with the same name

   In gdrive if I create a test folder with containing two children
   with the same name, and then ls it, I see both but they appear to
   have the same inode number.  I see that .dump conains reasonable
   stuff.  I think this is happening:

   . I return 2 correct direntry elements
   . Lookup gets called twice, based on name only
   . Each time I just grab the first entry and return that as a result of the Lookup call, so it ends up with the same Inode
   . I wonder what happens if I just don't implement Lookup.  It doesn't make sense if a directory can contain two files with the same name

   So this does appear to be the problem, and if I don't implement
   Lookup, then things won't work.

   I'm now thinking about forcing the files to have unique names
   within a directory.  Sticking .<idx> or .<creationdate> at the end
   would be one way to handle it.  Note that this could result in a
   new name collision which I would then have to handle, as unlikely
   as that is.

   I would need to make sure I don't end up writing this fake name
   back to gdrive by accident.

   Also, when new files appear, they can cause collisions.  In that
   case can I reliably apply the new suffix to just the new children?
   It will be confusing if an existing file is now renamed for no
   reason.

   I could add a data structure to each directory to track nodes per
   name to aid in this.

   We need to deal with these display names both when they come into
   use (e.g. Lookup) and we we return things (e.g. ReadDirAll, Attr).

   It seems like it would we want the parent to notice every time a
   new duplicate appears (or an old one goes away)?  When a new one
   appears, we would walk the duplicate children, and tell each of
   them they have a new unique display name they will use from then
   on.
** consider tracking last-viewed time as attr atime
** fileReader open aggressively fetches
   Currently whenever a file is opened for reading, we begin to
   download the content in the background immediately.  However, in
   the case that the kernel has the content in memory, it then just
   releases the open handle immediately, meaning we consumed network,
   drive resources without needing to.

   Maybe there is some way to know if the kernel is likely to call
   release right away and we could not launch the fetch in that case?

   Or maybe I just should not worry about it.
** setting file to zero length
  What I see when I do echo "foo" into bar.txt is that we are called
  to open bar.txt in write mode, without the truncate flag.  Then we
  are called to set the length to zero using setAttr.

  Once I start really supporting write, I would be downloading the
  file contents before returning from the open call (in case the
  writer wanted to seek or something).

  Maybe do this: if the file is opened in writeonly mode, delay
  fetching contents until the first write.  If they truncate via
  setattr before then, we can then skip ever downloading the contents.
** Umm, write mode
*** handling create calls
  Need to make open far smarter, and forward create all to it
  consider O_CREAT, O_EXCL, O_TRUNC
  also consider read/write
  also O_APPEND
  also O_ASYNC/O_FSYNC/O_SYNC
*** writing to existing file
  Need to start by downloading existing contents

  At the end when we are writing back, do we want to verify that the
  gdrive file has not changed beneath us?  Maybe we don't care and
  just do last-one-wins.
*** honor flush calls
*** mkdir
*** settattr
** Can we reduce change notification spam by filtering out fields we don't care about?
** Allow live configuration via writing to a magic file?  Could turn on and off logging etc.
** Do something useful with file modes
** Have some kind of /recent directory with symlinks to the actual nodes
** Track last-read-time of nodes, evict old ones to save memory
** concurrency noodling
*** file open multiple times by local os, at the same time
*** file being changed remotely while open locally
  . while open locally for reading and/or for writing
*** flush etc
  . should I be really pushing changes up on every flush?
* Notes
** compile-edit-debug cycle
  run this
  fusermount -u /tmp/mnt ; go install ;and go test  ./... ;and mnt-gdrive --writeable /tmp/mnt
