

* Things to work on next
* Things to work on at some point
** Investigate inotify support
See https://github.com/camlistore/camlistore/issues/244
See https://github.com/bazil/fuse/issues/34
See https://github.com/rvoicilas/inotify-tools/wiki
** Bug when 2 files with the same name

   In gdrive if I create a test folder with containing two children
   with the same name, and then ls it, I see both but they appear to
   have the same inode number.  I see that .dump conains reasonable
   stuff.  I think this is happening:

   . I return 2 correct direntry elements
   . Lookup gets called twice, based on name only
   . Each time I just grab the first entry and return that as a result of the Lookup call, so it ends up with the same Inode
   . I wonder what happens if I just don't implement Lookup.  It doesn't make sense if a directory can contain two files with the same name

   So this does appear to be the problem, and if I don't implement
   Lookup, then things won't work.

   I'm now thinking about forcing the files to have unique names
   within a directory.  Sticking .<idx> or .<creationdate> at the end
   would be one way to handle it.  Note that this could result in a
   new name collision which I would then have to handle, as unlikely
   as that is.

   I would need to make sure I don't end up writing this fake name
   back to gdrive by accident.

   Also, when new files appear, they can cause collisions.  In that
   case can I reliably apply the new suffix to just the new children?
   It will be confusing if an existing file is now renamed for no
   reason.

   I could add a data structure to each directory to track nodes per
   name to aid in this.

   We need to deal with these display names both when they come into
   use (e.g. Lookup) and we we return things (e.g. ReadDirAll, Attr).

   It seems like it would we want the parent to notice every time a
   new duplicate appears (or an old one goes away)?  When a new one
   appears, we would walk the duplicate children, and tell each of
   them they have a new unique display name they will use from then
   on.
** consider tracking last-viewed time as attr atime
** fileReader open aggressively fetches
   Currently whenever a file is opened for reading, we begin to
   download the content in the background immediately.  However, in
   the case that the kernel has the content in memory, it then just
   releases the open handle immediately, meaning we consumed network,
   drive resources without needing to.

   Maybe there is some way to know if the kernel is likely to call
   release right away and we could not launch the fetch in that case?

   Or maybe I just should not worry about it.
** Umm, write mode
*** handling create calls
  bug: look at truncate flag
  Need to make open far smarter, and forward create all to it
  consider O_CREAT, O_EXCL, O_TRUNC
  also consider read/write
  also O_APPEND
  also O_ASYNC/O_FSYNC/O_SYNC
*** writing to existing file
  Need to start by downloading existing contents

  At the end when we are writing back, do we want to verify that the
  gdrive file has not changed beneath us?  Maybe we don't care and
  just do last-one-wins.
*** honor flush calls
*** settattr  
*** mv
*** rm
** Can we reduce change notification spam by filtering out fields we don't care about?
** Allow live configuration via writing to a magic file?  Could turn on and off logging etc.
** Do something useful with file modes
** Have some kind of /recent directory with symlinks to the actual nodes
** Track last-read-time of nodes, evict old ones to save memory
